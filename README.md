DMSPFlow
====

简单的，基于四个主要分支的分支管理方法

## 概述

通常的软件工程，一般会经过开发、测试，最后发布生产三个阶段。团队在开发时，一般会按照功能拆分分支，或按个人拆分分支。但是在大多数情况下，一般一个团队或一个项目，只需要一个共用的开发分支。所以，本方法定义 develop、master、staging、production 四个主要分支管理代码。四个分支分别代表开发过程中的四个环境。

![示例](demo.png)

## 主要分支

**develop**

develop 分支主要用于日常开发，对应开发环境。

1. 如果不需要对功能的开发进行隔离和拆分的，所有开发人员可以都在该分支上进行开发。
1. 在这个分支上，只要不会扰乱其他在本分支上开发的开发人员。那么，这个分支几乎允许一切行为。例如随时进行回退（当然不会回退超过 master 分支），或者任意提交不稳定的代码等。

让团队的开发人员在一个分支上开发，是有好处的。当然，前提是小型团队。它可以让团队不需要拘泥于分支的切换、管理和操作上。各个功能在开发时，遇到需要共享的通用代码时，也不需要思考额外的方案来共享它们。另外，由于多人同一分支开发，也可以尽早的发现不稳定代码。提高代码健壮性，简介提高代码可读性等。省去了一部分代码审核（review）的工作。

**master**

master 分支作为核心分支，作为其他分支的来源分支。staging 分支和 production 分支都直接来自 master 分支。

develop 分支只有最初来自 master 分支。之后，develop 将作为 master 的来源。如果项目足够简单，团队成员水准一致，那么可以省略 develop 分支。直接将 master 作为 develop 分支。但是这么做，会要求所有提交的代码，必须要足够稳定。它不能像单纯的 develop 分支那样无拘无束。这么简单的要求，那为什么还需额外独立 develop 分支呢？主要是为了对代码增加可控的审核机制。

为了保证 master 代码的质量，master 分支不允许 Owner 和 Maintainer 之外的人提交代码。而非 master 分支之外的所有分支，即使是测试和生产环境也是如此，都可以由团队内成员任意提交。

这么做可以

1. 因为测试和生产环境被定义为 master 的下游。所以，即使成员可以随意提交代码。一旦代码需要更新，都可以使用 master 随意覆盖测试和生产环境；
1. 所有需要提交到 master 的代码，被强制需要由 Owner 或 Maintainer 成员合并或者提交。这样可以让 Owner 和 Maintainer 成员能被主动告知代码变动，并进行代码审核。

**staging** 和 **production**

staging 分支和 production 分支，分别对应测试环境和生产环境。这两个分支作为环境的发布分支。可以视为 master 上对应代码的拷贝，或者对应节点的引用。

一般来说，对测试环境的改动，一般是修复开发时期产生的 Bug 或功能缺陷。在测试环境的上游代码修改修复是正确的，或常规的操作。

除了以上的四个主要分支外，还定义了 hotfix 分支。主要用于做生产的临时修复。

## 为什么不是

### Git Flow

Git Flow 产生的环境不是当下这种，以 Web 为主，DevOps 快速集成的环境。Git Flow 定义的以功能为主，按版本发布的情况，更适合类似早期的 C/S 类似软件，或类似 Spring 这类大型框架项目。这些工程、项目的一个特点是，生产环境会存在多个分支版本。比如 Spring 发布的 Release 版本存在 4.x.x.RELEASE 和 5.x.x.RELEASE。两个生产版本在一定时间内，必须要有对应的维护（修补）。所以需要两个代码分支同时存在，并且某些代码需要同时集成到两个分支。而对于现在这种，以网络环境为主，B/S 架构的软件情况下，多数情况都是只有一个生产版本，并且进行一条主线的持续集成。此时，Git Flow 就显得非常负责，和冗余。

### Github Flow 或 Gitlab Flow

Github Flow 和 Gitlab Flow 是类似的操作流程，这两个流程以 master 分支为主力分支，作为发布和集成的核心。在流程的定义中，没有明确区分各软件环境对应的分支。如果按 master 作为生产分支，测试分支由个功能分支来实施的话，则需要额外定义流程规范。否则，依然容易造成分支管理混乱。

## 引用

1. http://www.ruanyifeng.com/blog/2015/12/git-workflow.html
1. https://nvie.com/posts/a-successful-git-branching-model/
